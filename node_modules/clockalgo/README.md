# clockalgo.js

Generative clock algorithm library.

## About

This JavaScript library is intended for use in Web Audio projects or other audio programming environments such as Max/MSP's Node for Max system. It is currently a work in progress and under active development.

### General Principles

* A musical clock in electronic music is like a metronome that provides a steady pulse marking the passage of time. 
* An algorithmic clock is a repeating pattern of pulses/gates
  * The pattern itself may not consist of evenly spaced beats/pulses
  * At a macro level, the pattern itself will repeat
* A generative, algorithmic clock is one in which multiple patterns can be combined and act on each other

## Clock Algorithms

### Simple

A simple clock is the most basic kind of clock and will generate a single beat at the start of the current sequence.

A simple clock is only available as a first algorithm.

### Euclidean

A Euclidean clock creates quantized subdivisions of the clock length. For example, given 16 steps and a Euclidena divisor/modulo of 5, the resulting gate pattern would have the following rhythm:

```
Step Count: 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
Gate:       1  0  0  1  0  0  1  0  0  0  1  0  0  1  0  0
```

Notice that because 16 divided by 5 produces a fractional remainder, the resulting gate pattern is not evenly distributed. There are four off gates between the third and fourth on gates.

Euclidean is only available as a first algorithm.

### Subdivider

A Subdivider clock evenly distributes the sequence's gate beats. Note that a Subdivider pattern will often develop off the grid beats. For example if the step count is set to 16 and the Euclidean divisions are set to 3, the beats/gates will be at the fractional steps 0, 5.33 and 10.67.

When a Subdivider algorithm is not the first sequence in a chain the Subdivider divisions will be applied between the current beats. If an algorithm ahead of Subdivider in the chain produces quantized gate steps at 0, 4 and 12, and the Subdivider divisions are set to 3, each of the sub-sections (0-3, 4-11 and 12-15) will each be divided into their own Euclidean subdivisions. The first and third will have smaller subdivisions than the second sub-section.

The Subdivider algorithm will always include all Subdivider beats because it is not quantized.

See also: Euclidean.

### Randomize

When a Randomize algorithm is used as the first algorithm, it will choose random beats. The number of random beats is based on a percentage calculated by `steps / on_steps` where `on_steps` comes from the slider's range of 0-16. The slider will err on the side of more gates by rounding the "on" gate step count up (Math ceiling function). Steps will be randomly selected from quantized step offsets.

When a Randomize algorithm is not the first sequence in a chain it will randomize a percentage of the previous steps.

### Tala

This is a **very** rudimentary and crude implementation of Indian Tala rhythms. It is only named as such to acknowledge source of the patterns. These patterns are useful starting rhythms to pass into other algorithms that are very musical but often asymmetrical. See the [`Tala` class in the JavaScript models](src/tala.js) for a list of which Tala rhythms are implemented. When the numeric step count does not match any implemented Tala it falls back to returning a simple clock.

Tala is only available as a first algorithm.

### Multiplier

A traditional multiplier implementation.

### Recursive

Recursive creates new divisions by recursively dividing a clock sequence. Make the first division and then repeat the process only to the left side of the new division. See this comparison of a clock divided by 2 and recursively subdivided by 2.

```
Pulse:               1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8
Original:            1 - - - - - - - 1 - - - - - - -
Traditional Divide:  1 - - - 1 - - - 1 - - - 1 - - -
Recursive Subdivide: 1 1 1 - 1 - - - 1 1 1 - 1 - - -
```

Recursively subdivided sequences are quantized.

### Rotator

Rotate a clock. For example given the clock gate sequence:

```1 0 1 0```

When rotated by 25%, it becomes:

```0 1 0 1```

### Swing

A traditional swing clipped to swing amounts between 15% and 85%. Note that the uneven beat/gate distances that can be generated means that all steps will not necessarily have the same swing percentages relative to each other.

## End of Chain Transformations

### Weighting

Weighting is an end-of-chain pattern manipulation. After one or more algorithms have produced a sequence of gates, this algorithm alters the sequence by shifting the gate pattern "to the left": the largest gap between samples is placed to the right of the buffer. Then the entire sequence should be modulo-style wrapped around so relative gate positions are preserved.

The idea here is that some patterns, especially when random is used sound unmusical. This provides a means of creating a rest/pause that will occur before a pattern finishes and its next loop iteration starts. A weighted sequence preserves the sequence structure but modulo wraps the pattern with a new start.

## Inspiration

This code is inspired by the description of [clockalgo by Rian Treanor in a DJ Mag article](https://djmag.com/longreads/studio-selections-rian-treanor).
