const HybridClock = require("./hybrid_clock");
const helpers     = require("./helpers");


/**
 * Acts as either a random clock generator or a randomizer of other clocks. 
 * 
 * When randomizing another Clockalgo.js clock, the Randomizer object will randomly move a specified percentage of
 * the clock's gates. By defining randomization as a process that **moves** existing gates (and is NOT defined
 * as a process that flips on-gates off conceptually), it will guarantee that an input clock being randomized
 * will produce an output clock with the same number of on-gates.
 *
 * Additionally, when randomizing another clock, the input clock's step count is significant. The steps will constrain
 * the position of the newly generated clock's divisions.
 */
class Randomizer extends HybridClock {

    /**
     * Create a new randomized clock.
     *
     * A new clock can be created from either combination of a percentage and step count or a percentage and
     * an input clock. For the former, the percentage specifies the number of steps that will be turned on. For
     * the latter, the percentage specifies the number of divisions in the input clock's divisions that will
     * be moved to a new position.
     *
     * @param {float} percentage a randomization amount between 0 a 1
     * @param {integer/clock} stepsOrClock either a step count or a Clockalgo.js clock
     */
    constructor(percentage, stepsOrClock) {
        super(stepsOrClock);

        percentage = percentage <= 0 ? 0 : percentage;
        percentage = percentage >= 1 ? 1 : percentage;

        if (typeof stepsOrClock === "number")
            this.divisions = Randomizer.generate(this.steps, percentage);
        else {
            // Edge case: there are no free steps that can be randomized.
            if (stepsOrClock.divisions.length == this.steps)
                this.divisions = stepsOrClock.divisions;
            else
                this.divisions = Randomizer.randomizeClockDivisions(stepsOrClock, percentage);
        }
    }


    /**
     * Randomize the divisions of a clock.
     *
     * @param {clock} clock a Clockalgo.js clock to be randomized
     * @param {float} percentage a percentage between 0 and 1 that specifies how many divisions to move
     * @returns {Array} an array of divisions based on the input clock that has been randomized
     */
    static randomizeClockDivisions(clock, percentage) {

        if (percentage <= 0) return clock.divisions;

        // Clone the Array to leave the input clock object intact
        let divisions = clock.divisions.slice(0).sort();
        let onStepIndices = new Array(), offStepIndices = new Array();

        // Since all we have is a clock divisions, use the input clock's step count to determine virtual step distances.
        let divIndex = 0;
        let quantizedDiv = 1.0 / clock.steps;
        let steps = [...Array(clock.steps).keys()].reduce((acc, stepIndex) => {
            acc[stepIndex] = { quantized: stepIndex * quantizedDiv };

            // If the next division is between this step and the next one, place it here.
            if (divisions[divIndex] >= acc[stepIndex].quantized && divisions[divIndex] < acc[stepIndex].quantized + quantizedDiv) {
                onStepIndices.push(stepIndex);
                acc[stepIndex].division = divisions[divIndex];
                divIndex++;
            } else {
                offStepIndices.push(stepIndex);
            }

            return acc;
        }, {});

        let onStepCount           = onStepIndices.length;
        let randomizedOnStepCount = Math.ceil(onStepCount * percentage);

        // Pick random on gates to turn off and random off gates to turn on
        let gateIndicesToEnable  = Randomizer.uniqueRandomIndices(offStepIndices.length, randomizedOnStepCount);
        let gateIndicesToDisable = Randomizer.uniqueRandomIndices(onStepIndices.length, randomizedOnStepCount);

        for (let i = 0; i < randomizedOnStepCount; i++) {
            let shiftedDivOffset = steps[onStepIndices[gateIndicesToDisable[i]]].division - steps[onStepIndices[gateIndicesToDisable[i]]].quantized;
            delete steps[onStepIndices[gateIndicesToDisable[i]]].division;
            steps[offStepIndices[gateIndicesToEnable[i]]].division = shiftedDivOffset + steps[offStepIndices[gateIndicesToEnable[i]]].quantized;
        }

        return Object.values(steps).filter(step => step.division != undefined).map(step => step.division);
    }


    // Use the URN technique for selecting numEntries from an Array.
    // This technique avoids randomly picking the same number twice.
    static uniqueRandomIndices(range, numEntries) {

        let randomIndices = new Array();
        let urn = new Array(range);
        for (let i = 0; i < range; i++)
            urn[i] = i;

        let randRange = range;
        for (let i = 0; i < numEntries; i++) {
            // Pick a random index from the URN between 0 and the current random range.
            let randomIndex = Math.floor(Math.random() * randRange);
            randomIndices.push(urn[randomIndex]);

            // Swap the randomly chosen gate index and the last entry in the URN
            let tmp = urn[randomIndex];
            urn[randomIndex] = urn[randRange - 1];
            urn[randRange - 1] = tmp;

            // Decrement the random range, so previously chosen random indices are not repicked
            randRange--;
        }

        return randomIndices;
    }


    /**
     * Generate a gate sequence (Array of 1's and 0's) that form the basis for clock divisions.
     *
     * @param {integer} numSteps the number of steps a clock sequence should contain
     * @param {float} percentage the percentage of steps that should be turned on
     * @returns {Array} of 1's and 0's that represents a gate sequence for the clock
     */
    static generate(numSteps, percentage) {

        if (percentage > 0) {
            let onStepCount = Math.floor(numSteps * percentage);
            let onStepIndices = Randomizer.uniqueRandomIndices(numSteps, onStepCount);
            return onStepIndices.map(stepIndex => stepIndex * (1.0 / numSteps)).sort();
        }

        return [];
    }
}


module.exports = Randomizer;
