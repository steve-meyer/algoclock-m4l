const SimpleClock      = require("./simple_clock");
const Euclidean        = require("./euclidean");
const Tala             = require("./tala");
const RecursiveDivider = require("./recursive_divider");
const Multiplier       = require("./multiplier");
const Subdivider       = require("./subdivider");
const Randomizer       = require("./randomizer");
const Swing            = require("./swing");
const Rotation         = require("./rotation");
const GateList         = require("./gate_list");


/**
 * ClockFactory is used to build a clock object from a clock specification.
 *
 * A clock is a simple object that primarily has a "divisions" property, which is an Array of gates represented
 * as numbers between 0 and 1.
 *
 * See the buildClock() method for details.
 */
class ClockFactory {

    /**
     * Create a new clock from a specification.
     *
     * A specification is a JavaScript object with the following structure:
     *
     *      { chain: [ clockspec1, clockspec2, ... clockspecN ] }
     *
     * Each clockspec in the chain is a JavaScript object. For example:
     *
     *      { type: "Euclidean", param1: 3, param2: 8 }
     *
     * The "type" property corresponds to a Clockalgo.js clock algorithm class name. The paramN properties are the
     * constructor arguments that should be passed to the class's constructor. For the Subdivider and Randomizer
     * classes, when they appear in any position after the first, the previous clock in the chain will be used as
     * param2.
     *
     * @param {object} specification a specification that describes a clock algorithm
     * @returns a Clockalgo.js clock object
     */
    static buildClock(specification) {

        let clock = specification.chain.reduce((clock, clockspec, i) => {
            if (i == 0)
                // Create the first clock in the chain from the spec
                clock = ClockFactory.getAlgorithm(clockspec.type, clockspec.param1, clockspec.param2);

            else if (clockspec.type == "Subdivider" || clockspec.type == "Randomizer")
                // The next chain item is a hybrid type: use current clock as second param when creating a new clock.
                clock = ClockFactory.getAlgorithm(clockspec.type, clockspec.param1, clock);

            else
                // Otherwise it is a modifier: create, then apply to current clock.
                clock.apply( ClockFactory.getAlgorithm(clockspec.type, clockspec.param1, clockspec.param2) );

            return clock;
        }, null);

        if (specification.weighted)
            clock.apply(new Rotation(ClockFactory.weightedRotationAmount(clock)));

        return clock;
    }


    static weightedRotationAmount(clock) {
        let [index, dist] = clock.divisions.reduce((acc, d, i, arr) => {
            let dist = i == arr.length - 1 ? (1 + arr[0] - d) : arr[i + 1] - d;
            if (acc[1] == undefined || dist > acc[1]) acc = [i, dist];
            return acc;
        }, new Array());

        // Handle the special case where the largest gap is betwen the last item and the
        // distance to wrap around to the first item.
        return index == clock.divisions.length - 1 ? 1 - clock.divisions[0] : (1 - clock.divisions[index + 1]);
    }


    /**
     * Get a clock algorithm object.
     *
     * @param {string} clocktype the class name of a Clockalgo.js clock algorithm
     * @param {number} parameter1 the first, distinctive parameter passed to a clock algorithm
     * @param {number/clock} steps the second parameter passed to a clock algorithm, typically a step count or clock algorithm
     * @returns a Clockalgo.js clock algorithm containing a divisions gate Array
     */
    static getAlgorithm(clocktype, parameter1, steps) {
        let clock;

        switch (clocktype) {
            case "Subdivider":
                clock = new Subdivider(parameter1, steps);
                break;
            case "Randomizer":
                clock = new Randomizer(parameter1, steps);
                break;
            case "SimpleClock":
                clock = new SimpleClock(parameter1);
                break;
            case "Euclidean":
                clock = new Euclidean(parameter1, steps);
                break;
            case "Tala":
                clock = new Tala(parameter1);
                break;
            case "Multiplier":
                clock = new Multiplier(parameter1);
                break;
            case "RecursiveDivider":
                clock = new RecursiveDivider(parameter1);
                break;
            case "Swing":
                clock = new Swing(parameter1);
                break;
            case "Rotation":
                clock = new Rotation(parameter1);
                break;
            case "GateList":
                clock = new GateList(parameter1);
                break;
            default:
                clock = new SimpleClock(16);
        }

        return clock;
    }
}


module.exports = ClockFactory;
