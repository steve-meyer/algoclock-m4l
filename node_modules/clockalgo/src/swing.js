const ClockModifier = require("./clock_modifier");
const Subdivider    = require("./subdivider");


/**
 * Add swing to a clock.
 *
 * Swing will shift every other division in a clock by a swing amount.
 *
 * For all clocks except a Subdivider clock, the swing amount is a percentage of the distance
 * between the clock's steps. For a Subdivider clock, the swing amount is a percentage of the
 * distance between divisions.
 */
class Swing extends ClockModifier {

    /**
     * Create a new Swing modifier.
     *
     * @param {float} swingAmount the amount of swing as a percentage between 0.15 and 0.85
     */
    constructor(swingAmount) {
        super();

        // Follow the clipping in Max/MSP [swing~] object.
        swingAmount = swingAmount < 0.15 ? 0.15 : swingAmount;
        swingAmount = swingAmount > 0.85 ? 0.85 : swingAmount;
        this.swingAmount = swingAmount;
    }


    /**
     * Apply this object's swing amount to the clock's divisions.
     *
     * @param {clock} clock the clock to apply swing to
     */
    applyTo(clock) {
        if (clock instanceof Subdivider) {
            clock.divisions = clock.divisions.map((step, i, arr) => {
                // No swing for the odd divisions or the last division
                if (i % 2 == 0 || i == arr.length - 1)
                    return step;
                // Even samples that are not the last one are swung based on the distance to the right neighbor
                else
                    return step + (arr[i + 1] - step) * this.swingAmount;
            });
        } else {
            let divSwing = (1.0 / clock.steps) * this.swingAmount;
            clock.divisions = clock.divisions.map((step, i) => step + ((i % 2) * divSwing));
        }

    }
}


module.exports = Swing;
