const ClockModifier = require("./clock_modifier");
const helpers       = require("./helpers");
const SimpleClock   = require("./simple_clock");


/**
 * A clock modifier that recursively divides a sequence into smaller divisions.
 *
 * Example: given a simple clock with 16 steps and a recursive divisor of 2, the recursive steps are...
 *
 * Input Seq:             [1, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0]
 * Recursive Subdivide 1: [1, 0, 0, 0,   0, 0, 0, 0,   1, 0, 0, 0,   0, 0, 0, 0]
 * Recursive Subdivide 2: [1, 0, 0, 0,   1, 0, 0, 0,   1, 0, 0, 0,   1, 0, 0, 0]
 * Recursive Subdivide 3: [1, 0, 1, 0,   1, 0, 0, 0,   1, 0, 1, 0,   1, 0, 0, 0]
 * Recursive Subdivide 4: [1, 1, 1, 0,   1, 0, 0, 0,   1, 1, 1, 0,   1, 0, 0, 0]
 *
 * Number 4 represents the final output state that the clock's divisions will be based on. At each step
 * the input sequence is subdivided "to the left," as it were. The recursion stops when there are no
 * more steps to "turn on."
 *
 * For clocks that are not the SimpleClock class, the subdivisions are based on the input clock's divisions
 * and the smallest subdivision amount cannot be smaller than a computed step amount: 1.0 / inputclock.steps.
 * This means that in order to achieve more subdivisions, a clock with a higher number of steps is required.
 * This method is chose in order to retain both the flexibility of irregular clock divisions (i.e., that
 * don't line up perfectly on a grid) and some semblance of identity with the input clock (namely its step
 * count).
 */
class RecursiveDivider extends ClockModifier {

    /**
     * Create a new RecursiveDivider
     *
     * @param {integer} divisor the number of sections a clock should be divided into recursively
     */
    constructor(divisor) {
        super();
        this.divisor = divisor;
    }


    /**
     * Modify the specified clock by recursively subdividing it by this object's divisor.
     *
     * Modifies the data in the supplied clock.
     *
     * @param {clock} clock a Clockalgo.js clock object
     */
    applyTo(clock) {

        if (this.divisor <= 1) {
            // do nothing
        } else if (clock instanceof SimpleClock) {
            let sequence = RecursiveDivider.subdivideByStepCount(clock.steps, this.divisor);
            clock.divisions = helpers.divisionsFromSequence(sequence);
        } else {
            clock.divisions = RecursiveDivider.divideSegments(clock.divisions, clock.steps, this.divisor);
        }
    }


    /**
     * Divide each segment (space between divisions) of an array of clock divisions.
     *
     * @param {Array} clockDivisions the array from the divisions property of a Clockalgo.js clock
     * @param {integer} stepCount the step count of a clock that will determine the recursion amount
     * @param {integer} divisor the divisor that determines how many times each segment will be subdivided
     * @returns a new array of divisions after subdividing the input divisions
     */
    static divideSegments(clockDivisions, stepCount, divisor) {
        let subdivisions = new Array();
        let minLength = 1.0 / stepCount;

        clockDivisions.push(1);
        clockDivisions.forEach((div, i, arr) => {
            if (i < arr.length - 1) {
                let segmentLength = arr[i + 1] - div;
                subdivisions.push(...RecursiveDivider.divideSegment(segmentLength, divisor, minLength, div).sort());
            }
        });

        return subdivisions;
    }


    /**
     * Divide a single segment (space between divisions) from an array of clock divisions.
     *
     * @param {float} segmentLength a division segment length
     * @param {integer} divisor the divisor that determines how many times each segment will be subdivided
     * @param {float} minLength the threshold determining the smallest amount that should be subdivided
     * @param {float} offset the segment offset to be added to any divisions created
     * @returns an array of divisions for a segment
     */
    static divideSegment(segmentLength, divisor, minLength, offset) {

        let divisions     = new Array(1).fill(offset);
        let currentLength = segmentLength;

        while (currentLength >= minLength) {
            currentLength = currentLength / divisor;
            if (currentLength >= minLength)
                divisions.push(currentLength + offset);
        }

        return divisions;
    }


    /**
     * Generate a recursively subdivided gate array of 1's and 0's by specifying an array lenght and divisor
     *
     * @param {integer} numSteps the number of steps in the seqeunce to be subdivided
     * @param {integer} divisor the divisor that determines how many times each segment will be subdivided
     * @returns a gate array of 1's and 0's that represent a subdivided sequence
     */
    static subdivideByStepCount(numSteps, divisor) {
        let steps = new Array(numSteps).fill(0);

        // Edge case: a step counts/divisions that do not divide the step count into any subdivisions
        if (divisor <= 1 || divisor > numSteps) {
            steps[0] = 1;
            return steps;
        }

        for (let div = 0; div < divisor; div++) {
            let offset = div * Math.floor(numSteps / divisor);
            steps[offset] = 1;
            for (let gate = Math.floor((numSteps/divisor) / divisor); gate > 0; gate = Math.floor(gate/divisor)) {
                steps[gate + offset] = 1;
            }
        }

        return steps;
    }
}


module.exports = RecursiveDivider;
